/**
 * Google Gemini API Client Configuration and Utilities
 */

const fetch = require("node-fetch");
const functions = require("firebase-functions");

class GeminiClient {
  constructor() {
    this.apiKey = functions.config().gemini?.key || process.env.GEMINI_API_KEY;
    this.baseUrl = "https://generativelanguage.googleapis.com/v1beta";
    this.modelName = "gemini-2.5-flash"; // Fixed: Use correct stable model name
  }

  /**
   * Generate content using Gemini model
   * @param {string} prompt - The prompt to send
   * @param {object} options - Additional options
   * @returns {Promise<string>} The AI response
   */
  async generateContent(prompt, options = {}) {
    if (!this.isConfigured()) {
      throw new Error("Gemini API key is not configured");
    }

    console.log(`ðŸ¤– Using Gemini model: ${this.modelName}`);

    try {
      const requestBody = {
        contents: [
          {
            parts: [
              {
                text: `You are a professional fitness expert and exercise specialist. ${prompt}`,
              },
            ],
          },
        ],
        generationConfig: {
          maxOutputTokens: options.maxTokens || 1000,
          temperature: options.temperature || 0.3,
          topP: options.topP || 0.8,
          topK: options.topK || 40,
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE",
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_MEDIUM_AND_ABOVE",
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE",
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE",
          },
        ],
      };

      const response = await fetch(
        `${this.baseUrl}/models/${this.modelName}:generateContent?key=${this.apiKey}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(requestBody),
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        let errorData = {};
        try {
          errorData = JSON.parse(errorText);
        } catch (e) {
          // If parsing fails, use the raw text
        }

        console.error(`Gemini API Error: ${response.status}`, errorData);
        throw new Error(
          `Gemini API error: ${response.status} - ${
            errorData.error?.message || errorText
          }`
        );
      }

      const data = await response.json();
      console.log("ðŸ” Full Gemini response:", JSON.stringify(data, null, 2));

      // Check if response has candidates
      if (!data.candidates || data.candidates.length === 0) {
        console.error("âŒ No candidates in Gemini response:", data);
        // Check for other error indicators
        if (data.error) {
          throw new Error(
            `Gemini API error: ${
              data.error.message || JSON.stringify(data.error)
            }`
          );
        }
        throw new Error("No content generated by Gemini");
      }

      const candidate = data.candidates[0];
      console.log("ðŸŽ¯ Candidate details:", JSON.stringify(candidate, null, 2));

      // Check for safety blocking
      if (candidate.finishReason === "SAFETY") {
        console.error("ðŸ›¡ï¸ Content blocked by safety filters");
        throw new Error("Content was blocked by safety filters");
      }

      // Check for other finish reasons that might indicate issues
      if (candidate.finishReason && candidate.finishReason !== "STOP") {
        console.warn(`âš ï¸ Unusual finish reason: ${candidate.finishReason}`);
      }

      // Check for content
      if (
        !candidate.content ||
        !candidate.content.parts ||
        candidate.content.parts.length === 0
      ) {
        console.error("âŒ No content parts in candidate:", candidate);
        throw new Error("No text content in Gemini response");
      }

      const textPart = candidate.content.parts[0];
      console.log("ðŸ“ Text part:", JSON.stringify(textPart, null, 2));

      const generatedText = textPart.text;
      if (!generatedText || generatedText.trim() === "") {
        console.error("âŒ Empty or null text in response");
        throw new Error("Empty text in Gemini response");
      }

      console.log("âœ… Generated text length:", generatedText.length);
      return generatedText.trim();
    } catch (error) {
      console.error("Gemini API Error:", error);

      // Don't re-wrap our own errors
      if (error.message.includes("Gemini")) {
        throw error;
      }

      throw new Error(`Gemini request failed: ${error.message}`);
    }
  }

  /**
   * Validate that the Gemini API key is configured
   * @returns {boolean} True if API key is available
   */
  isConfigured() {
    return !!this.apiKey && this.apiKey.length > 10;
  }

  /**
   * Get the model name being used
   * @returns {string} Model name
   */
  getModelName() {
    return this.modelName;
  }

  /**
   * Test the API connection
   * @returns {Promise<boolean>} True if API is working
   */
  async testConnection() {
    try {
      const response = await this.generateContent(
        'Hello, respond with just "OK"',
        {
          maxTokens: 10,
          temperature: 0,
        }
      );
      return response.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Gemini connection test failed:", error);
      return false;
    }
  }
}

// Export singleton instance
module.exports = new GeminiClient();
